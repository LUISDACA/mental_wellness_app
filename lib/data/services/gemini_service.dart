import 'dart:convert';
import 'package:google_generative_ai/google_generative_ai.dart';
import '../../core/env.dart';
import '../../core/constants.dart';
import '../../core/logger.dart';

/// Type of emotion analysis performed
enum AnalysisType {
  /// Full AI analysis using Gemini models
  ai,

  /// Basic pattern-matching analysis (offline mode or fallback)
  heuristic,
}

class EmotionResult {
  final String emotion; // happiness|sadness|anxiety|anger|neutral
  final double score; // 0..1
  final int severity; // 0..100
  final String advice; // breve consejo (es)
  final AnalysisType type; // AI or heuristic analysis

  EmotionResult({
    required this.emotion,
    required this.score,
    required this.severity,
    required this.advice,
    this.type = AnalysisType.ai,
  });

  /// Returns true if this result was generated by AI, false if heuristic
  bool get isAiGenerated => type == AnalysisType.ai;

  /// Returns true if this is a crisis-level emotion
  bool get isCrisis => severity >= AppConstants.crisisSeverityThreshold;
}

class GeminiService {
  static final _fallbackModels = <String>[
    if (Env.geminiModel.isNotEmpty) Env.geminiModel,
    ...AppConstants.geminiModelFallbacks,
  ];

  GenerativeModel? _jsonModel;
  GenerativeModel? _chatModel;
  bool _ready = false;

  GeminiService() {
    if (Env.geminiApiKey.isEmpty && !Env.offlineMode) {
      AppLogger.error(
        'GEMINI_API_KEY not configured',
        tag: 'GeminiService',
      );
      throw StateError(AppConstants.errorMissingGeminiKey);
    }
  }

  // ---------------- helpers ----------------
  Map<String, dynamic>? _tryParseJson(String raw) {
    // 1) directo
    try {
      return json.decode(raw) as Map<String, dynamic>;
    } catch (_) {}

    // 2) bloque ```json ... ```
    final fenced =
        RegExp(r'```(?:json)?\s*(\{[\s\S]*?\})\s*```', multiLine: true);
    final m = fenced.firstMatch(raw);
    if (m != null) {
      try {
        return json.decode(m.group(1)!);
      } catch (_) {}
    }

    // 3) del primer '{' al último '}'
    final s = raw.indexOf('{');
    final e = raw.lastIndexOf('}');
    if (s != -1 && e != -1 && e > s) {
      final cut = raw.substring(s, e + 1);
      try {
        return json.decode(cut);
      } catch (_) {}
    }
    return null;
  }

  EmotionResult _heuristicAnalyze(String text) {
    final t = text.toLowerCase();
    String emotion = AppConstants.emotionNeutral;
    int severity = 30;
    double score = 0.7;
    String advice =
        'Tómate 1 minuto para respirar 4–4–4 y escribe una línea sobre cómo te sientes.';

    // crisis (palabras de riesgo alto)
    final crisisPattern = AppConstants.crisisKeywords.join('|');
    final crisis = RegExp('($crisisPattern)');
    if (crisis.hasMatch(t)) {
      AppLogger.warning(
        'Crisis keywords detected in heuristic analysis',
        tag: 'GeminiService',
      );
      return EmotionResult(
        emotion: AppConstants.emotionSadness,
        score: 0.9,
        severity: 95,
        advice:
            '⚠️ (Análisis básico) Siento que te sientas así. No estás solo/a. Busca ayuda inmediata: '
            'marca ${AppConstants.emergencyNumberSpain}/${AppConstants.emergencyNumberUS} o la línea local de prevención. '
            'Habla con alguien de confianza ahora mismo.',
        type: AnalysisType.heuristic,
      );
    }

    if (t.contains('ansie') || t.contains('nervio') || t.contains('preocup')) {
      emotion = AppConstants.emotionAnxiety;
      severity = 60;
      advice =
          'Prueba 4–7–8 y una pausa breve. Reduce estímulos y enfócate en un paso pequeño.';
    } else if (t.contains('triste') ||
        t.contains('deprim') ||
        t.contains('solo')) {
      emotion = AppConstants.emotionSadness;
      severity = 55;
      advice =
          'Escribe 3 cosas pequeñas para hoy y contacta a alguien de confianza.';
    } else if (t.contains('enojo') ||
        t.contains('rabia') ||
        t.contains('molest') ||
        t.contains('ira')) {
      emotion = AppConstants.emotionAnger;
      severity = 65;
      advice =
          'Respira lento 10 veces y camina 5 min antes de responder o actuar.';
    } else if (t.contains('feliz') ||
        t.contains('content') ||
        t.contains('alegr')) {
      emotion = AppConstants.emotionHappiness;
      severity = 20;
      advice =
          'Celebra el momento y anótalo en tu diario: fortalece el hábito positivo.';
    }

    return EmotionResult(
      emotion: emotion,
      score: score,
      severity: severity,
      advice: '⚠️ (Análisis básico) $advice',
      type: AnalysisType.heuristic,
    );
  }

  // -----------------------------------------

  Future<void> _ensureReady() async {
    if (Env.offlineMode) {
      AppLogger.info('Running in offline mode', tag: 'GeminiService');
      return;
    }

    if (_ready && _jsonModel != null && _chatModel != null) {
      AppLogger.debug('Gemini models already initialized', tag: 'GeminiService');
      return;
    }

    AppLogger.info('Initializing Gemini models...', tag: 'GeminiService');

    for (final name in _fallbackModels) {
      try {
        AppLogger.debug('Trying model: $name', tag: 'GeminiService');
        final test = GenerativeModel(
          model: name,
          apiKey: Env.geminiApiKey,
          generationConfig: GenerationConfig(
            temperature: AppConstants.emotionAnalysisTemperature,
            responseMimeType: 'application/json',
            maxOutputTokens: AppConstants.emotionAnalysisMaxTokens,
          ),
        );
        final r = await test.generateContent([Content.text('{"ping":"ok"}')]);
        if ((r.text ?? '').isNotEmpty) {
          _jsonModel = test;
          _chatModel = GenerativeModel(
            model: name,
            apiKey: Env.geminiApiKey,
            generationConfig: GenerationConfig(
              temperature: AppConstants.chatTemperature,
              maxOutputTokens: AppConstants.chatMaxTokens,
            ),
          );
          _ready = true;
          AppLogger.info(
            'Successfully connected with model: $name',
            tag: 'GeminiService',
          );
          return;
        }
      } catch (e) {
        AppLogger.warning(
          'Model $name failed, trying next: $e',
          tag: 'GeminiService',
        );
        // Continue to next model
      }
    }

    AppLogger.error(
      'All Gemini models failed to initialize',
      tag: 'GeminiService',
    );
    throw StateError(AppConstants.errorNoGeminiModels);
  }

  Future<EmotionResult> analyzeText(String text) async {
    if (Env.offlineMode) {
      AppLogger.info('Using heuristic analysis (offline mode)', tag: 'GeminiService');
      return _heuristicAnalyze(text);
    }

    await _ensureReady();
    final basePrompt = '''
Eres un asistente empático de bienestar mental. Devuelve SOLO JSON válido (sin markdown, sin texto extra) en minúsculas:
{"emotion":"happiness|sadness|anxiety|anger|neutral","score":0..1,"severity":0..100,"advice":"breve consejo en español"}
Usuario: "$text"
''';

    // 1er intento (JSON puro)
    try {
      final res = await _jsonModel!.generateContent([Content.text(basePrompt)]);
      final raw = (res.text ?? '{}').trim();
      final map = _tryParseJson(raw);

      if (map == null) {
        AppLogger.warning('Failed to parse JSON from first attempt', tag: 'GeminiService');
        throw StateError('no-json');
      }

      final result = EmotionResult(
        emotion: (map['emotion'] ?? AppConstants.emotionNeutral) as String,
        score: ((map['score'] ?? 0.0) as num).toDouble(),
        severity: ((map['severity'] ?? 0) as num).toInt(),
        advice: (map['advice'] ?? '') as String,
        type: AnalysisType.ai,
      );

      AppLogger.debug(
        'AI analysis completed: ${result.emotion} (severity: ${result.severity})',
        tag: 'GeminiService',
      );

      return result;
    } catch (e) {
      AppLogger.warning(
        'First AI attempt failed: $e',
        tag: 'GeminiService',
      );

      // 2º intento: prompt ultra-restricto
      final strict = '''
SOLO JSON. NADA DE TEXTO EXTRA. Formato exacto:
{"emotion":"happiness|sadness|anxiety|anger|neutral","score":0..1,"severity":0..100,"advice":"texto"}
Texto: "$text"
''';
      try {
        final res2 = await _jsonModel!.generateContent([Content.text(strict)]);
        final raw2 = (res2.text ?? '{}').trim();
        final map2 = _tryParseJson(raw2);

        if (map2 == null) {
          AppLogger.warning('Failed to parse JSON from second attempt', tag: 'GeminiService');
          throw StateError('no-json-2');
        }

        final result = EmotionResult(
          emotion: (map2['emotion'] ?? AppConstants.emotionNeutral) as String,
          score: ((map2['score'] ?? 0.0) as num).toDouble(),
          severity: ((map2['severity'] ?? 0) as num).toInt(),
          advice: (map2['advice'] ?? '') as String,
          type: AnalysisType.ai,
        );

        AppLogger.info(
          'AI analysis succeeded on second attempt',
          tag: 'GeminiService',
        );

        return result;
      } catch (e2, stack2) {
        AppLogger.error(
          'Both AI attempts failed, falling back to heuristic analysis',
          error: e2,
          stack: stack2,
          tag: 'GeminiService',
        );
        // heurística como último recurso
        return _heuristicAnalyze(text);
      }
    }
  }

  Future<String> chatOnce(String message,
      {List<({String role, String content})> history = const []}) async {
    if (Env.offlineMode) {
      AppLogger.info('Using offline chat mode', tag: 'GeminiService');
      // mini heurística
      final m = message.toLowerCase();
      final crisisPattern = AppConstants.crisisKeywords.join('|');
      if (RegExp('($crisisPattern)').hasMatch(m)) {
        AppLogger.warning('Crisis keywords detected in chat', tag: 'GeminiService');
        return 'Siento mucho que te sientas así. No estás solo/a. Si corres riesgo inmediato, '
            'busca ayuda urgente (${AppConstants.emergencyNumberSpain}/${AppConstants.emergencyNumberUS} o línea local). '
            '¿Puedo acompañarte mientras contactas a alguien de confianza?';
      }
      if (m.contains('triste')) {
        return 'Lamento que te sientas triste. Probemos 4 respiraciones lentas. ¿Qué te aliviaría un poquito ahora?';
      }
      if (m.contains('ansie')) {
        return 'La ansiedad es difícil. Intentemos 4–7–8 un minuto. ¿Qué pequeño paso puedes dar hoy?';
      }
      if (m.contains('enojo') || m.contains('rabia')) {
        return 'Es válido sentir enojo. Da 10 respiraciones y camina 5 min antes de actuar.';
      }
      return 'Estoy contigo. Respiremos 4–4–4. Cuéntame un poco más para ayudarte mejor.';
    }

    try {
      await _ensureReady();
      final buf = StringBuffer()
        ..writeln(
            'Eres un asistente empático de bienestar emocional. Responde en español, breve, cálido y práctico.')
        ..writeln(
            'Evita diagnósticos; sugiere respiración, pausas, journaling, contacto social seguro.');
      if (history.isNotEmpty) {
        buf.writeln('\nHistorial:');
        for (final h in history) {
          buf.writeln(h.role == 'user'
              ? 'Usuario: ${h.content}'
              : 'Asistente: ${h.content}');
        }
      }
      buf.writeln('\nUsuario: $message\nAsistente:');

      final r = await _chatModel!.generateContent([Content.text(buf.toString())]);
      final response = r.text ?? '';

      AppLogger.debug(
        'Chat response generated (${response.length} chars)',
        tag: 'GeminiService',
      );

      return response;
    } catch (e, stack) {
      AppLogger.error(
        'Chat generation failed',
        error: e,
        stack: stack,
        tag: 'GeminiService',
      );
      return 'Lo siento, tuve un problema técnico. ¿Podrías intentar de nuevo?';
    }
  }
}
